{
    "collab_server" : "",
    "contents" : "# library(sp)\n####################### Classe Grid #################################################\n#\n# date          version         auteur                          commentaire\n# 2016/08/09      0.0.5      Francois Semecurbe     \n# 2016/08/11      0.0.7      Francois Semecurbe     première version déployée sur le CRAN\n# 2016/__/__      0.0.8      Arlindo Dos Santos     \n# 2016/08/31      0.0.9      Francois Semecurbe     version diffusée à Audric Sophie et Cacheux Lionel\n# 2016/10/03      0.1.0      Arlindo Dos Santos     version avec la fonction kernelSmoothingMedian\n# 2016/10/04      0.1.1      Arlindo Dos Santos     correction de bugs mineurs\n# 2016/10/14      0.1.2      Arlindo Dos Santos     4 modes d'appels pour kernelSmoothing\n# 2016/12/01      0.1.4      Arlindo Dos Santos     fonction retour updateProgress pour kernelSmoothing\n# 2017/01/01      0.1.6      Arlindo Dos Santos     prise en compte du paramètre neighbor si indiqué (et 0 si userGrid fournie)\n# 2017/01/11      0.1.7      Arlindo Dos Santos     fonction retour updateProgress pour smoothingToGrid\n# 2017/01/11      0.1.8      Arlindo Dos Santos     ajout de la colonne nbObsMin pour le lissage classique\n#\n##########################################################################################\n\n#' @useDynLib btb\n#' @importFrom Rcpp evalCpp\n#' @import methods sp\n\n#Grid est le nom de la classe definie\n#les slots sont des variables typées\n#' @export\nsetClass(\n  Class = \"Grid\",\n  slots = list(cellSize = \"integer\", bandwidth = \"integer\"),\n  contains = \"data.frame\"\n)\n\n#' @export\nsetMethod(\n  `[`,\n  signature = signature(x = \"Grid\"),\n  function(x, ...){\n    # Save the original\n    storedtdt <- x\n    # Use the fact that x is a subclass to \"data.frame\"\n    Nargs <- nargs()\n    hasdrop <- \"drop\" %in% names(sys.call())\n    if (Nargs == 2) {\n      tmpDF <- `[.data.frame`(x, i = TRUE, j = i, ..., drop = FALSE)\n    } else if ((Nargs == 3 && hasdrop)) {\n      tmpDF <- `[.data.frame`(x, i = TRUE, j = i, ..., drop)\n    } else if (hasdrop) {\n      tmpDF <- `[.data.frame`(x, i, j, ..., drop)\n    } else {\n      tmpDF <- `[.data.frame`(x, i, j, ...)\n    }\n    # Reintegrate the results\n    if (inherits(x = tmpDF, what = \"data.frame\"))\n    {\n      for (sName in names(getSlots(\"data.frame\")))\n      {\n        slot(storedtdt, sName) <- slot(tmpDF, sName)\n      }\n      return(storedtdt)\n    } else {\n      return(tmpDF)\n    }\n  })\n\n#' @export\nsetMethod(\n  `[<-`,\n  signature = signature(x = \"Grid\"),\n  function(x, ..., value){\n    # Save the original\n    storedtdt <- x\n    # Use the fact that x is a subclass to \"data.frame\"\n    Nargs <- nargs()\n    if (any(!names(sys.call()) %in% c(\"\", \"i\", \"j\", \"value\"))) {\n      stop(\"extra arguments are not allowed\")\n    }\n    tmpDF <- data.frame(x)\n    if (Nargs == 3) {\n      if (missing(i)) \n        i <- j\n      tmpDF[i] <- value\n    } else if (Nargs == 4) {\n      tmpDF[i, j] <- value\n    }\n    # Reintegrate the results\n    for (sName in names(getSlots(\"data.frame\")))\n    {\n      slot(storedtdt, sName) <- slot(tmpDF, sName)\n    }\n    return(storedtdt)\n  })\n\n############################## smoothingToGrid() #######################################################################\n# fonction pour transformer un lissage en un fond de carte\n#' @export\nsmoothingToGrid <- function(grid, epsg, fUpdateProgress = NULL)\n{\n\n  if (is.null(fUpdateProgress))\n  {\n    # version optimisee sans compte-rendu d'avancement du traitement\n    carreauSpeed <- function(x, y, cellSize) \n    {\n      sp::Polygons(list(sp::Polygon(\n        cbind(\n          c(0, cellSize, cellSize, 0, 0) + x - cellSize / 2,\n          c(0, 0, cellSize, cellSize, 0) + y - cellSize / 2\n        )\n      )\n      ), paste(x, y, sep = \"_\")\n      )\n    }\n    \n    grille <- mapply(carreauSpeed, grid[, \"x\"], grid[, \"y\"], MoreArgs = list(grid@cellSize))\n  }\n  else\n  {\n    carreauSlow <- function(i, grid, n, fUpdateProgress, startTime) {\n      x <- grid[i, \"x\"]\n      y <- grid[i, \"y\"]\n      \n      if (i == n)\n      {# traitement du dernier polygone\n        dTempsPasse = Sys.time() - startTime\n        message <- paste0(\"\\rGrid progress: \", ceiling(i / n * 100), \"% - Elapsed time: \", floor(as.numeric(dTempsPasse, units = \"mins\") / 60), \"m \", floor(as.numeric(dTempsPasse, units = \"secs\")) %% 60, \"s   \")\n        cat(message)\n        fUpdateProgress(100, message)\n      }\n      else if (i %% floor( n / 100) == 0)\n      {\n        iPourcentageEffectue <- ceiling(i / n * 100)\n        dTempsPasse = Sys.time() - startTime\n        dTempsTotal <- dTempsPasse * 100 / iPourcentageEffectue;\n        iTempsRestant <- ceiling(dTempsTotal - dTempsPasse);\n        message <- paste0(\"\\rGrid progress: \", iPourcentageEffectue, \"% - remaining time: \", floor(as.numeric(iTempsRestant, units = \"mins\") / 60), \"m \", as.numeric(iTempsRestant, units = \"secs\") %% 60, \"s   \")\n        cat(message)\n        fUpdateProgress(iPourcentageEffectue, message)\n      }\n      \n      sp::Polygons(list(sp::Polygon(\n            cbind(\n              c(0, grid@cellSize, grid@cellSize, 0, 0) + x - grid@cellSize / 2,\n              c(0, 0, grid@cellSize, grid@cellSize, 0) + y - grid@cellSize / 2\n            )\n          )\n        ), paste(x, y, sep = \"_\")\n      )\n    }\n    \n    cat(\"\\n\")\n    dateDebutTraitement <- Sys.time()\n    grille <- lapply(1:nrow(grid), carreauSlow, grid, length(grid@.Data[[1]]), fUpdateProgress, dateDebutTraitement)\n    cat(\"\\n\")\n  }\n\n  # on crée un spatial polygon avec un code epsg de projection defini\n  grille_spat <- sp::SpatialPolygons((grille), proj4string = sp::CRS(paste0(\"+init=epsg:\", epsg)))\n  df <- data.frame(grid@.Data)\n  names(df) <- names(grid)\n  data <- data.frame(ID = paste(df[, \"x\"], df[, \"y\"], sep = \"_\"), df)\n\n  # un SpatialPolygonsDataFrame est un SpatialPolygon auquel on attache une table d'attributs\n  return(sp::SpatialPolygonsDataFrame(grille_spat, data, match.ID = \"ID\"))\n}\n\n############################## kernelSmoothing() #######################################################################\n# constructeur public\n# \n# arguments\n# dfObservations  : data.frame comportant les coordonnées géographiques (x,y), ainsi que les variables que l'on souhaite lisser\n# cellSize        : Taille des carreaux\n# bandwidth       : Rayon de lissage\n# neighbor        : Paramètre technique pour calculer l'étendue des points d'estimation\n# vQuantiles      : vecteur de quantiles à utiliser pour le lissage median\n# dfCentroids     : data.frame avec deux colonnes, nommées x et y avec les coordonnees des centroides à utiliser\n# fUpdateProgress : fonction permettant d'offrir à l'appelant une estimation de l'avancement du traitement \n# neighbor        : Paramètre technique pour calculer l'étendue des points d'estimations, à ne pas remplir\n# \n# retourne\n# un objet Grid dont le slot @data contient la valeur des variables lissees\n# \n#' @export\nkernelSmoothing <-\n  function(dfObservations\n          , cellSize\n          , bandwidth\n          , vQuantiles = NULL\n          , dfCentroids = NULL\n          , fUpdateProgress = NULL\n          , neighbor = NULL\n  )\n  {\n    cellSize <- as.integer(cellSize)\n    bandwidth <- as.integer(bandwidth)\n    dRayonMinimum <- cellSize * sqrt(2) / 2\n    \n    if(is.null(neighbor))\n    {\n      if (is.null(dfCentroids)) \n        neighbor <- max(0, ceiling(bandwidth / cellSize / 2L) - 1L) \n      else \n        neighbor <- 0\n    }\n    \n    if (bandwidth < dRayonMinimum)\n    {\n      stop(\"bandwidth must be greater than cellSize * sqrt(2) / 2\")\n    }\n    \n    if (cellSize <= 0)\n    {\n      stop(\"cellSize must be greater than 0\")\n    }\n    \n    # les coordonnées des observations ne doivent pas être NA\n    if (length(dfObservations[is.na(dfObservations$x), ]$x) + length(dfObservations[is.na(dfObservations$y), ]$y) > 0)\n    {\n      stop(\"NA coordinates are not allowed\")\n    } \n    \n    # vérifier la regularite des centroides fournis par l'utilisateur\n    if (!is.null(dfCentroids))\n    {\n      xOffset <- (dfCentroids$x + cellSize / 2) %% cellSize\n      yOffset <- (dfCentroids$y + cellSize / 2) %% cellSize\n      if (!all(xOffset == xOffset[1]) | !all(yOffset == yOffset[1]) )\n      {\n        stop(\"Centroids are not regular\")\n      }\n    }else\n    {\n      xOffset <- 0\n      yOffset <- 0\n    }\n\n    if (anyNA(dfObservations) )\n    {\n      warning(\"Be careful! NA values detected in your observations\")\n    }\n    \n    if (is.null(dfCentroids))\n    { \n      # calcul de l'indice des observations - on prend le rectangle englobant et on positionne le debut de la numérotation sur la première observation\n      dfObservations$i <- as.integer(floor((dfObservations$x - xOffset[1]) / cellSize) - floor(min(dfObservations$x / cellSize)) + 1)\n      dfObservations$j <- as.integer(floor((dfObservations$y - yOffset[1]) / cellSize) - floor(min(dfObservations$y / cellSize)) + 1)\n      \n      # calcul des centroides\n      dfCentroids <- data.frame( x = as.integer(floor(dfObservations$x / cellSize) * cellSize + (cellSize / 2)),\n                                 y = as.integer(floor(dfObservations$y / cellSize) * cellSize + (cellSize / 2))\n      )\n\n      # les observations sont positionnées sur une matrice. mIndices[i, j] == 1 indique qu'il y a au moins 1 observation pour le carreau (i,j)\n      mIndices <- matrix(0L, max(dfObservations$i), max(dfObservations$j))\n      mIndices[cbind(dfObservations$i, dfObservations$j)] <- 1L\n      \n      # construction d'une matrice des indices des centroides étendue au voisinage\n      mIndicesEtendus <- matrix(0L, nrow(mIndices) + 2 * neighbor, ncol(mIndices) + 2 * neighbor)\n      \n      # décalage de la matrice d'index sur la matrice étendue, ce qui permet de compter combien de fois un carreau est nécessaire\n      for (voisin_x in -neighbor:neighbor)\n      {\n        for (voisin_y in -neighbor:neighbor)\n        {\n          mIndicesEtendus[neighbor + 1:nrow(mIndices) + voisin_x, neighbor + 1:ncol(mIndices) + voisin_y] <- \n            mIndicesEtendus[neighbor + 1:nrow(mIndices) + voisin_x, neighbor + 1:ncol(mIndices) + voisin_y] + mIndices\n        }\n      }\n      \n      # la matrice d'indices étendue est transformée en vecteurs de coordonnées\n      vIndicesEtendus <- which(mIndicesEtendus > 0, arr.ind = TRUE)\n      rm(list = c(\"mIndicesEtendus\", \"mIndices\"))\n      \n      # retour aux coordonnées\n      vX <- as.integer(round(min(dfCentroids$x) + (vIndicesEtendus[, 1] - 1 - neighbor) * cellSize))\n      vY <- as.integer(round(min(dfCentroids$y) + (vIndicesEtendus[, 2] - 1 - neighbor) * cellSize))\n      dfCentroidesUniques <- data.frame(x = vX, y = vY, i = vIndicesEtendus[, 1], j = vIndicesEtendus[, 2])\n      \n      rm(list = c(\"vX\", \"vY\", \"vIndicesEtendus\", \"dfCentroids\"))\n    }else\n    {\n      # Remarque: il n'est pas nécessaire de rapatrier les observations dans les carreaux de la grille fournie.\n      # lors du lissage, les observations enverront leur contribution uniquement vers les carreaux fournis\n      \n      # calcul de l'indice des observations - on commence la numérotation pour la coordonnée minimale (qu'elle soit détenue par une observation ou un centroide)\n      obsEtCentroides <- data.frame(x = c(dfObservations$x, dfCentroids$x), y = c(dfObservations$y, dfCentroids$y))\n      indiceMinX <- floor(min(obsEtCentroides$x / cellSize))\n      indiceMinY <- floor(min(obsEtCentroides$y / cellSize))\n        \n      dfObservations$i <- as.integer(floor((dfObservations$x - xOffset[1]) / cellSize) - indiceMinX + 1)\n      dfObservations$j <- as.integer(floor((dfObservations$y - yOffset[1]) / cellSize) - indiceMinY + 1)\n      \n      # calcul de l'indice des centroides\n      dfCentroids$i <- as.integer(floor(dfCentroids$x / cellSize) - indiceMinX + 1)\n      dfCentroids$j <- as.integer(floor(dfCentroids$y / cellSize) - indiceMinY + 1)\n      dfCentroidesUniques <- dfCentroids\n    }\n      \n    nomColonnes <- colnames(dfObservations)\n    listVar <- nomColonnes[nomColonnes != \"x\" & nomColonnes != \"y\" & nomColonnes != \"i\" & nomColonnes != \"j\"]\n    \n    if (is.null(vQuantiles))\n    {\n      # numérotation des centroides - décalage de -1 pour faire commencer la numerotation des lignes à 0 pour le traitement c++\n      dfCentroidesUniques$index <- (1:nrow(dfCentroidesUniques)) - 1L\n      \n      # transformation en matrice\n      mXcentroides = mIcentroides = mYcentroides = matrix(NA, max(dfCentroidesUniques$j), max(dfCentroidesUniques$i))\n      mXcentroides[cbind(dfCentroidesUniques$j, dfCentroidesUniques$i)] <- dfCentroidesUniques$x\n      mYcentroides[cbind(dfCentroidesUniques$j, dfCentroidesUniques$i)] <- dfCentroidesUniques$y\n      mIcentroides[cbind(dfCentroidesUniques$j, dfCentroidesUniques$i)] <- dfCentroidesUniques$index\n      \n      iNbCentroidesUniques <- nrow(dfCentroidesUniques)\n      dfResultat <- data.frame(dfCentroidesUniques[, c(\"x\", \"y\")])\n      \n      mVariablesLissees <- rcppLissage(\n          dfObservations$x\n        , dfObservations$y\n        , dfObservations$i\n        , dfObservations$j\n        , cellSize\n        , bandwidth\n        , neighbor\n        , as.matrix(dfObservations[, listVar])\n        , mXcentroides\n        , mYcentroides\n        , mIcentroides\n        , iNbCentroidesUniques\n        , fUpdateProgress\n      )\n      \n      rm(list = c(\"dfObservations\", \"mXcentroides\", \"mYcentroides\", \"mIcentroides\"))\n      \n      dfResultat <- cbind(dfResultat, mVariablesLissees)\n      names(dfResultat) <- c(\"x\",\"y\", listVar)\n      # names(dfResultat) <- c(\"x\",\"y\", listVar, \"nbObsPondere\") # version pour calcul de la colonne nbObsPondere\n      \n      rm(mVariablesLissees)\n      \n      return(new(Class = \"Grid\", dfResultat, cellSize = cellSize, bandwidth = bandwidth))    \n    }else\n    {\n      mMedianes <- rcppLissageMedianSort(\n          dfObservations$x\n        , dfObservations$y\n        , bandwidth\n        , as.matrix(dfObservations[, listVar])\n        , dfCentroidesUniques$x\n        , dfCentroidesUniques$y\n        , vQuantiles\n        , fUpdateProgress\n      )\n    \n      rm(dfObservations)\n      \n      dfResultat <- data.frame(cbind(dfCentroidesUniques$x, dfCentroidesUniques$y))\n      dfResultat <- cbind(dfResultat, mMedianes)\n      \n      vNomQuantiles <- gsub(\"\\\\.\", \"\", as.character(vQuantiles))\n      \n      dfListeVar <- expand.grid(vNomQuantiles, listVar)\n      lNewVarNames <- paste0(dfListeVar[, 2], \"_\", dfListeVar[, 1])\n      lNewVarNames <- c(\"x\", \"y\", \"nbObs\", lNewVarNames)    \n      colnames(dfResultat) <- lNewVarNames\n      \n      return(new(Class = \"Grid\", dfResultat, cellSize = cellSize, bandwidth = bandwidth))\n    }\n  }\n",
    "created" : 1486565672528.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1122888861",
    "id" : "64189EA8",
    "lastKnownWriteTime" : 1487687114,
    "last_content_update" : 1487687114,
    "path" : "D:/programmation/R/btb/R/Grid.R",
    "project_path" : "R/Grid.R",
    "properties" : {
        "docOutlineSize" : "169.37584596058525",
        "docOutlineVisible" : "0"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}