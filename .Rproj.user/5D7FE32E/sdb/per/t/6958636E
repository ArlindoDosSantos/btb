{
    "collab_server" : "",
    "contents" : "#include <Rcpp.h>       // Rcpp::Rcout\n#include <time.h>       // clock_t, clock, CLOCKS_PER_SEC\n#include <math.h>       // pow \n\nusing namespace Rcpp;\n\n/*\n *    date        version         auteur              commentaire\n * 2016/08/09      0.1.3      Arlindo Dos Santos      remplacement de l'appel à clock_gettime  par clock()\n *                                                  \n */\n\n/* \n*  arguments\n*  vXobservations : vecteur avec les coordonnées x des observations\n*  vYobservations : vecteur avec les coordonnées y des observations\n*  vIndicesX      : vecteur avec l'indice i des observations \n*  vIndicesY      : vecteur avec l'indice j des observations \n*  iPas           : longueur du côté d'un carreau\n*  iRayon         : rayon de lissage         \n*  iNeighbor      : voisinage étendu                                 \n*  mVar           : matrice avec les variables non lisees\n*  mXcentroides   : matrice contenant la valeur de la coordonnée x pour les centroides, stocke en (i;j) ou i est le numero d'ordre en abscisse du carreau et j le numero d'ordre en ordonnée du carreau\n*  mYcentroides   : matrice contenant la valeur de la coordonnée y pour les centroides, stocke en (i;j) ou i est le numero d'ordre en abscisse du carreau et j le numero d'ordre en ordonnée du carreau\n*  mIcentroides   : matrice contenant le numéro d'ordre du centroide, stocké en (i;j) où i est le numéro d'ordre en abscisse du carreau et j le numéro d'ordre en ordonnée du carreau\n*  iNbCentroides  : nombre de centroides\n*  \n*  retourne \n*  une matrice \"mVariablesLissees\" contenant les différentes variables en colonnes et les valeurs lissées en ligne\n*  cette matrice ne comporte pas les coordonnées des centroides ni des observations\n*/\n// [[Rcpp::export]]\nNumericMatrix rcppLissage(\n                    NumericVector vXobservations\n                  , NumericVector vYobservations\n                  , NumericVector vIndicesX\n                  , NumericVector vIndicesY\n                  , int iPas\n                  , int iRayon\n                  , int iNeighbor\n                  , NumericMatrix mVar\n                  , NumericMatrix mXcentroides\n                  , NumericMatrix mYcentroides\n                  , NumericMatrix mIcentroides\n                  , int iNbCentroides\n                  , Nullable <Function> updateProgress = R_NilValue\n)\n{\n  // debut benchmark\n  clock_t timeBegin = clock();\n  double dTempsPasse;\n  double dTempsTotal = 0;\n  int iTempsRestant = 0;\n  int iPourcentageEffectue;\n  int iPourcentageEffectuePrecedent = 0;\n  std::stringstream message;\n  // fin benchmark\n\n  int i, j;\n  int iMin, iMax, jMin, jMax;\n  int iVarCourante;\n  int iNbVoisins = ceil(double(iRayon) / iPas - 0.5);   // le cercle de rayon iRayon est circonscrit dans le rectangle de 2*iNbVoisins * 2*iNbVoisins\n  int iNbCentroidesAbscisse = mXcentroides.ncol();\n  int iNbCentroidesOrdonnee = mXcentroides.nrow();\n  int iNbVars = mVar.ncol();                // nombre de variables a traiter\n  int iNbObs = vXobservations.length();     // nombre d'observations\n  long double dRayonCarre = std::pow((long double)iRayon, 2); // rayon de lissage au carre\n  long double dDistanceCarre;               // distance au carré entre une observation et un centroide\n  long double dSommePonderation;            // double contenant la somme des ponderations qui sont appliquées depuis l'observation considérée\n\n  NumericMatrix mPonderation(iNbCentroidesOrdonnee, iNbCentroidesAbscisse);   // matrice contenant la ponderation a appliquer a la valeur du centroide pour l'observation consideree\n  NumericMatrix mVariablesLissees(iNbCentroides, iNbVars);  // matrice contenant le resultat (variables lissees)\n  // NumericMatrix mVariablesLissees(iNbCentroides, iNbVars + 1);  // matrice contenant le resultat (variables lissees) version avec nbObsPondere\n  \n  /* on parcourt toutes les observations */\n  for(int iIndiceObsCourante = 0; iIndiceObsCourante < iNbObs; ++iIndiceObsCourante)\n  {\n    dSommePonderation = 0;\n    \n    // i est l'indice en abscisse (numéro de colonne) \n    iMin = fmax(vIndicesX[iIndiceObsCourante] + iNeighbor - iNbVoisins - 1, 0);\n    iMax = fmin(vIndicesX[iIndiceObsCourante] + iNeighbor + iNbVoisins, iNbCentroidesAbscisse - 1);\n    \n    // j est l'indice en ordonnée (numéro de ligne)\n    jMin = fmax(vIndicesY[iIndiceObsCourante] + iNeighbor - iNbVoisins - 1, 0);\n    jMax = fmin(vIndicesY[iIndiceObsCourante] + iNeighbor + iNbVoisins, iNbCentroidesOrdonnee - 1);\n    \n    /* on parcourt tous les centroides susceptibles d'être intéréssé par cette observation */\n    for(i = iMin; i <= iMax; ++i)\n    {\n      for(j = jMin; j <= jMax; ++j)\n      {\n        // vérifier que le centroide est bien dans la grille fournie par l'utilisateur\n        if(NumericVector::is_na (mXcentroides(j, i)))\n          continue;\n\n        dDistanceCarre = std::pow(long(vXobservations[iIndiceObsCourante]) - mXcentroides(j, i), 2) + std::pow(long(vYobservations[iIndiceObsCourante]) - mYcentroides(j, i), 2);\n\n        if (dDistanceCarre < dRayonCarre)\n        {\n          mPonderation(j, i) = std::pow(1 - (dDistanceCarre / dRayonCarre), 2);\n          dSommePonderation += mPonderation(j, i);\n          // mVariablesLissees(mIcentroides(j, i), iNbVars) += mPonderation(j, i); // calcul de la colonne nbObsPondere\n        }\n      }\n    }\n    \n    if(dSommePonderation > 0)\n    {\n      for(i = iMin; i <= iMax; ++i)\n      {\n        for(j = jMin; j <= jMax; ++j)\n        {\n          for (iVarCourante = 0; iVarCourante < iNbVars; ++iVarCourante) /* pour chacune des variables a lisser */\n          {\n            /* on calcule le lissage : pondération de la valeur de la variable par le poids de lissage afin de normaliser sa valeur */\n            mVariablesLissees(mIcentroides(j, i), iVarCourante) += mVar(iIndiceObsCourante, iVarCourante) * mPonderation(j, i) / dSommePonderation;\n          }\n          mPonderation(j, i) = 0;\n        }\n      }\n    }\n\n    // debut benchmark\n    dTempsPasse = (clock() - timeBegin) / CLOCKS_PER_SEC;\n    iPourcentageEffectue = 100 * iIndiceObsCourante / iNbObs;\n    if(iPourcentageEffectuePrecedent != iPourcentageEffectue)  \n    {\n      dTempsTotal = dTempsPasse * 100 / iPourcentageEffectue;\n      iTempsRestant = ceil(dTempsTotal - dTempsPasse);\n      iPourcentageEffectuePrecedent = iPourcentageEffectue;\n      message.str(\"\");\n      message << \"Smoothing progress: \" << iPourcentageEffectue << \"% - minimum remaining time: \" << (iTempsRestant / 60) << \"m \" << (iTempsRestant % 60) << \"s\";\n      if(updateProgress.isNotNull())\n        as<Function>(updateProgress)(iPourcentageEffectue, message.str());\n      else\n        Rcpp::Rcout << \"\\r\" << message.str();\n    }\n    // fin benchmark\n  }\n\n  // debut benchmark\n  message.str(\"\");\n  message << \"Smoothing duration: \" << floor(dTempsTotal / 60) << \"m \" << ((int)dTempsTotal % 60) << \"s                                                                                           \";\n  if(updateProgress.isNotNull())\n    as<Function>(updateProgress)(iPourcentageEffectue, message.str());\n  else\n    Rcpp::Rcout << \"\\n\" << message.str();\n  // fin benchmark\n  \n  return(mVariablesLissees);\n}\n",
    "created" : 1499184447241.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1434270994",
    "id" : "6958636E",
    "lastKnownWriteTime" : 1499179366,
    "last_content_update" : 1499179366,
    "path" : "D:/S3QCEA/programmation/R/btb/src/rcppLissage.cpp",
    "project_path" : "src/rcppLissage.cpp",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}