{
    "collab_server" : "",
    "contents" : "options(encoding = \"UTF-8\")\noptions(shiny.maxRequestSize = 1 * 1024 ^ 2) # taille maximum pour le upload des fichiers fond de carte (1 Mo)\noptions(shiny.trace = FALSE)\noptions(shiny.reactlog = FALSE)\nsource(\"utils.R\")\n\n#### Application ALICE (Application web de LIssage CartographiquE) - permet d'appeler le package de carroyage/lissage \"btb\"\n#\n# date        version         auteur                    commentaire\n# 2016/10/27  0.0.1      Arlindo Dos Santos\n# 2017/05/19  0.0.2      Arlindo Dos Santos\n# \n# RG 00: Toujours travailler en local avec une version de R identique à celle de REC et Prod afin de se prémunir de problèmes de compatibilité de versions de packages\n# RG 01: Le fichier .DB doit comporter une seule table\n# RG 02: Le fichier .DB doit comporter des coordonnées en Lambert 93  => RG obsolete ?\n# RG 03: Le fichier .DB doit comporter une colonne nbObsLisse à 1 pour toutes les observations\n# RG 04: Les carreaux ayant moins de NB_OBS_MIN observations ne sont ni affichés ni exportés (secret statistique)\n# RG 05: Seules les carreaux ayant un nbObsLisse > NB_OBS_MIN et les NB_MAX_CARREAUX carreaux ayant le plus grand nbObsLisse sont affichés\n# RG 06: Les variables contenant au moins un NA dans leur modalité sont supprimées\n# RG 07: Les variables non numériques sont supprimées\n# RG 08: Le nom du répertoire contenant les sources de données doit être identique au nom  => RG obsolete ?\n# RG 09: Les valeurs des categories sont arondies à l'unité; il faut donc multiplier les pourcentatges pour les mettre sur base 100\n# RG 10: Catégorisation k-means pour des questions de performance\n# RG 11: Taille maximale du fichier fond de carte uploadé: 10 Mo (estimation empirique)\n# RG 12: S'il y a des suppressions de colonnes à effectuer, elles seront déclarées dans le traitement post lissage\n# RG 13: Ne pas utiliser de cat; lui préférer l'appel à la fonction trace définie dans utils.R\n####\n\nWINDOWS <- \"windows\"\nplatformOS <- .Platform$OS.type\nNB_MAX_CARREAUX <- 5000\nMAX_RAYON <- 4000\nRAYON_INITIAL <- 400\nNB_OBS_MIN <- 10\n# vNuancesRouge <- c(\"#fef0d9\", \"#fdcc8a\", \"#fc8d59\", \"#e34a33\", \"#b30000\")\nvNuancesRouge <- c(\"#2c7bb6\", \"#abd9e9\", \"#ffffbf\", \"#fdae61\", \"#d7191c\")\n\nbibliotheque <- paste0(getwd(), \"/\", \"packages\")\n.libPaths(bibliotheque)  # mettre dans le path le chemin où sont stockées les bibliothèques compilées\n\nlibrary(shiny, lib.loc = bibliotheque, warn.conflicts = FALSE, quietly = TRUE, verbose = FALSE)\nlibrary(DBI, lib.loc = bibliotheque, warn.conflicts = FALSE, quietly = TRUE, verbose = FALSE)\nlibrary(RSQLite, lib.loc = bibliotheque, warn.conflicts = FALSE, quietly = TRUE, verbose = FALSE)\nlibrary(cartography, lib.loc = bibliotheque, warn.conflicts = FALSE, quietly = TRUE, verbose = FALSE)\nlibrary(rgdal, lib.loc = bibliotheque, warn.conflicts = FALSE, quietly = TRUE, verbose = FALSE)\nlibrary(sp, lib.loc = bibliotheque, warn.conflicts = FALSE, quietly = TRUE, verbose = FALSE)\nlibrary(scales, lib.loc = bibliotheque, warn.conflicts = FALSE, quietly = TRUE, verbose = FALSE)\nlibrary(leaflet, lib.loc = bibliotheque, warn.conflicts = FALSE, quietly = TRUE, verbose = FALSE)\nlibrary(DT, lib.loc = bibliotheque, warn.conflicts = FALSE, quietly = TRUE, verbose = FALSE)\nlibrary(classInt, lib.loc = bibliotheque, warn.conflicts = FALSE, quietly = TRUE, verbose = FALSE)\nlibrary(btb, lib.loc = bibliotheque, warn.conflicts = FALSE, quietly = TRUE, verbose = FALSE)\n\nurlFondDeCarte <- 'http://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png'\ncheminBasesDonnees <- \"D:/S3QCEA/bases/\"\n\ncoucheQPVMetropole <- NULL\n\npbMessageParDefaut <- \"Traitement en cours:\"\npbDetailParDefaut <- \"aucun\"\n\nnomFichierConfSource <- \"sources.properties\"\n##################### fonctions commune à toutes les sessions ##########################################################\n\ncontextualisation <- function()\n{\n  if (platformOS == WINDOWS)\n  {\n    # ceci n'est pas à faire sur les env de recette et prod car la commande zip existe par défaut sur ces environnements\n    Sys.setenv(R_ZIPCMD = \"D:/S3QCEA/Program_Files/Rtools/bin/zip\")\n    \n    # stop en debug en cas d'erreur\n    options(shiny.error = browser)\n    \n    setwd(\"D:/S3QCEA/programmation/R/ALICE\") # local (debug)\n\n    # output back to the console\n    # sink(type = \"message\")\n    # sink()\n  \n    # # output to a file\n    dateHeure <- substr(x = Sys.time(), start = 1, stop = 19)\n    dateHeure <- Sys.Date()\n    dateHeure <- gsub(pattern = \":\", replacement = \"_\", x = dateHeure)\n    dateHeure <- gsub(pattern = \" \", replacement = \"_\", x = dateHeure)\n    newStdout <- file(paste0(getwd(), \"/logs/server_\", dateHeure, \".log\"), open = \"a\", encoding = \"UTF-8\", blocking = FALSE)\n    sink(newStdout)\n    sink(newStdout, type = \"message\", append = TRUE)\n  }\n  else\n  {\n    cheminBasesDonnees <<- paste0(getwd(), \"/bases\")\n\n    # output to a file\n    dateHeure <- substr(x = Sys.time(), start = 1, stop = 19)\n    dateHeure <- Sys.Date()\n    dateHeure <- gsub(pattern = \":\", replacement = \"_\", x = dateHeure)\n    dateHeure <- gsub(pattern = \" \", replacement = \"_\", x = dateHeure)\n    newStdout <- file(paste0(getwd(), \"/logs/server_\", dateHeure, \".log\"), open = \"a\", encoding = \"UTF-8\", blocking = FALSE)\n    sink(newStdout)\n    sink(newStdout, type = \"message\", append = TRUE)\n  }\n  cheminFichierQPV <- paste0(getwd(), \"/QPV/QPV.shp\")\n  coucheQPVMetropole <<- readOGR(cheminFichierQPV, \"QPV\")\n  coucheQPVMetropole <<- spTransform(coucheQPVMetropole, CRS = CRS(\"+init=epsg:4326\")) # transformation en WGS84 pour le leaflet\n  \n  serverPropertyFileName <- paste0(getwd(), \"/properties/server.properties\")\n  NB_MAX_CARREAUX <<- as.numeric(fctReadProperty(serverPropertyFileName, fields = c(\"NB_MAX_CARREAUX\"))[[1]])\n  MAX_RAYON <<- as.numeric(fctReadProperty(serverPropertyFileName, fields = c(\"MAX_RAYON\"))[[1]])\n  RAYON_INITIAL <<- as.numeric(fctReadProperty(serverPropertyFileName, fields = c(\"RAYON_INITIAL\"))[[1]])\n  NB_OBS_MIN <<- as.numeric(fctReadProperty(serverPropertyFileName, fields = c(\"NB_OBS_MIN\"))[[1]])\n  traceLevel <<- fctReadProperty(serverPropertyFileName, fields = c(\"trace.level\"))\n  \n  # calculer les centroides de toutes les zones\n  epsgPivot <<- as.numeric(fctReadProperty(serverPropertyFileName, fields = c(\"epsgPivot\"))[[1]])\n  nbZones <- as.numeric(fctReadProperty(serverPropertyFileName, fields = c(\"nbZones\"))[[1]])\n  vNbZones <- seq(from = 1, to = nbZones)\n  \n  vCleZonesNom <- paste0(\"zone.\", vNbZones, \".nom\")\n  vCleZonesEPSG <- paste0(\"zone.\", vNbZones, \".epsg\")\n  vZonesNom <- as.character(mapply(fctReadProperty, serverPropertyFileName, vCleZonesNom))\n  vZonesEPSG <<- as.character(mapply(fctReadProperty, serverPropertyFileName, vCleZonesEPSG))\n  \n  vCouches <- mapply(rgdal::readOGR, paste0(getwd(), \"/zones\"), vZonesNom)\n  vCouches <- mapply(sp::spTransform, vCouches, paste0(\"+init=epsg:\", epsgPivot))\n  vCentroideZones <<- mapply(rgeos::gCentroid, vCouches)\n}\n\ngetListUsersAutorises <- function()\n{\n  propertyFileName <- paste0(getwd(), \"/properties/authentification.properties\")\n  fctReadProperty(propertyFileName)\n}\n\ncontextualisation()\nlisteUsersAutorises <<- getListUsersAutorises()\n\n####################### fonctions propre à chaque session ##############################################################\nshinyServer(\n  function(input, output, session)\n  {\n    # vérification de l'autorisation d'accès\n    output$autorisation <- eventReactive(input$btnConnexion, {\n      if (toupper(input$login) %in% toupper(names(listeUsersAutorises)))\n      {\n        index <- which(toupper(names(listeUsersAutorises)) == toupper(input$login))\n        \n        nom <- strsplit(x = listeUsersAutorises[[index]], split = \";\")[[1]][1]\n        motDePasseAttendu <- strsplit(x = listeUsersAutorises[[index]], split = \";\")[[1]][2]\n\n        if (input$password == motDePasseAttendu)\n        {\n          trace(traceLevel, \"autorisation TRUE\", \"DEBUG\")\n          output$nomUser <- renderUI({div(nom, style = \"font-weight: bold\")})\n          \"TRUE\"\n        }else{\n          trace(traceLevel, \"autorisation FALSE\", \"DEBUG\")\n          output$messageConnexion <- renderText({\"mot de passe incorrect\"})\n          \"FALSE\"\n        }\n      }\n      else{\n        trace(traceLevel, \"autorisation FALSE\", \"DEBUG\")\n        output$messageConnexion <- renderText({\"login inconnu\"})\n        \"FALSE\"\n      }\n    })\n    outputOptions(output, \"autorisation\", suspendWhenHidden = FALSE) # pour forcer l'évaluation de la variable autorisation\n    \n    # affichage du menu des libellés des variables\n    output$menuVariables <- DT::renderDataTable({\n\n      propertyFileName <- paste0(getwd(), \"/properties/sources.properties\")\n      iNbSources <- fctReadProperty(propertyFileName, \"nbSources\")[[1]]\n\n      dfToutesSources <- data.frame(source = c(), variable = c(), descriptif = c(), stringsAsFactors = FALSE)\n\n      for (iSource in 1:iNbSources)\n      {\n        nomSource <- fctReadProperty(propertyFileName, paste0(\"source.\", iSource))[[1]]\n        lLibelles <- fctReadProperty(propertyFileName, paste0(nomSource, \".variables\"))[[1]]\n        lLibelles <- gsub(pattern = \"\\t\", replacement = \"\", x = lLibelles)\n        vCleLibelles <- strsplit(x = lLibelles, split = \";\")[[1]]\n\n        vVariable <- unlist(lapply(1:length(vCleLibelles), function(i) {\n          return(strsplit(x = vCleLibelles[[i]], split = \"=>\")[[1]][1])\n        }))\n\n        vDiffusible <- unlist(lapply(1:length(vCleLibelles), function(i) {\n          return(strsplit(x = vCleLibelles[[i]], split = \"=>\")[[1]][2])\n        }))\n        \n        vDescriptif <- unlist(lapply(1:length(vCleLibelles), function(i) {\n          return(strsplit(x = vCleLibelles[[i]], split = \"=>\")[[1]][3])\n        }))\n        \n        df <- data.frame(source = nomSource, variable = vVariable, diffusible = vDiffusible, descriptif = vDescriptif, stringsAsFactors = FALSE)\n\n        dfToutesSources <- rbind(dfToutesSources, df)\n      }\n\n      DT::datatable(dfToutesSources)\n    })\n    \n    # affichage du menu \"version de R\"\n    output$versionDeR <- renderUI({\n      message <- paste0(\"<tr>\", \"<td>\", names(R.version), \": </td><td><b>\", R.version, \"</b></td></tr>\")\n      message <- toString(message)\n      message <- gsub(\", \", \"\", message)\n      message <- paste0(\"<table>\", message, \"</table>\")\n      HTML(message)\n      }\n    )\n    \n    updateRayonMin <- eventReactive(input$pas, {ceiling(input$pas / 2 ^ 0.5)})\n    updateRayonMax <- eventReactive(input$pas, {input$pas * 20})\n    \n    # le nouveau style ne fonctionne pas en recette; certainement dû à une autre version du package shiny \n    # qui serait chargée mais qui ne me serait pas accessible.\n    # progress <- shiny::Progress$new(style = \"notification\")    \n    progress <- shiny::Progress$new()\n    progress$set(value = 0, message = pbMessageParDefaut, detail = pbDetailParDefaut)\n\n    ####### fonction de mise à jour de l'avancée de la barre de progression #######\n    updateProgress <- function(value = NULL, message = NULL) \n    {\n      if (value == 1)\n      { \n        progress$set(value = value / 100)\n      }\n      else if (value >= 99)\n      {\n        trace(traceLevel, message, \"INFO\")\n        progress$set(value = 0, detail = message)\n      }\n      else\n      {\n        trace(traceLevel, message, \"DEBUG\")\n        progress$set(value = (value / 100), detail = message)\n      }\n    }\n    \n    ####### affichage des packages chargés en mémoire #######\n    output$tableDesPackages <- DT::renderDataTable({\n      trace(traceLevel, \"############ affichage des packages chargés en mémoire ############\", \"DEBUG\")\n      \n      listePackages <- search()\n      listePackages <- listePackages[listePackages != \"Autoloads\"]\n      listePackages <- listePackages[listePackages != \"tools:rstudio\"]\n      listePackages <- listePackages[listePackages != \".GlobalEnv\"]\n      listePackages <- gsub(\"package:\", \"\", listePackages)\n      listePackages <- sort(listePackages)\n\n      packageDeBase <- function(nomPackage) \n      {\n        if (is.null(packageDescription(nomPackage)))\n          return(FALSE)\n        \n        if (is.null(packageDescription(nomPackage)$Priority))\n          return(FALSE)\n          \n        if (packageDescription(nomPackage)$Priority != \"base\")\n          return(FALSE)\n          \n          return(TRUE)\n      }\n      dfListePackages <- data.frame(nomPackage = listePackages, base = \"\", stringsAsFactors = FALSE)\n      dfListePackages$base <- sapply(dfListePackages$nomPackage, packageDeBase)\n      dfListePackages <- dfListePackages[dfListePackages$base == FALSE, ]\n      \n      if (platformOS == WINDOWS)\n        DT::datatable(installed.packages()[dfListePackages$nomPackage, c(\"Package\", \"LibPath\", \"Version\", \"Depends\", \"NeedsCompilation\", \"Built\")])\n      else\n\t\t    DT::datatable(installed.packages(lib.loc = paste0(getwd(), \"/packages\"))[dfListePackages$nomPackage, c(\"Package\", \"LibPath\", \"Version\", \"Depends\", \"NeedsCompilation\", \"Built\")])\n    })\n    \n    ####### affichage du curseur pour le rayon de lissage #######\n    observe({\n      # utiliser le update plutôt que de refaire à chaque fois le slider permet d'éviter l'oscillation du slider\n      if (is.null(input$sliderRayon))\n        rayonCourant <- RAYON_INITIAL\n      else if (input$sliderRayon < updateRayonMin())\n        rayonCourant <- updateRayonMin()\n      else if (input$sliderRayon > updateRayonMax())\n        rayonCourant <- updateRayonMax()\n      else\n        rayonCourant <- input$sliderRayon\n      \n      min <- updateRayonMin() + 50 - updateRayonMin() %% 50\n      updateSliderInput(session, \"sliderRayon\", value = rayonCourant, min = min, max = updateRayonMax(), step = 50)\n    })\n\n    ####### affichage du sélecteur de base de donnée #######\n    observeEvent(input$inputFiles,\n     {\n       trace(traceLevel, \"############ affichage du sélecteur de base de donnée ############\", \"DEBUG\")\n\n       # TODO: vérifier la présence des 4 fichiers\n       output$inputDatas <- renderUI(\n         {\n           listeNomFichiersBases <- list.files(cheminBasesDonnees, pattern = \".db\", recursive = TRUE)\n           listeBases <- strsplit(listeNomFichiersBases, \"\\\\.\")\n           vNomBases <- unlist(listeBases)\n           vNomBases <- vNomBases[vNomBases != \"db\"]\n           vNomBases <- cbind(\"\",  vNomBases)\n           \n           selectInput('inputDatas', 'Source de données :', choices = vNomBases) \n         }\n       )\n     }\n    )\n    \n    ####### sélection du territoire étudié #######\n    territoire <- eventReactive(input$inputFiles, \n     {\n       trace(traceLevel, \"############ sélection du territoire étudié ############\", \"DEBUG\")\n        dir <- dirname(input$inputFiles[1, 4])   # pour récuperer le shp\n        for (i in 1:nrow(input$inputFiles))      # on renomme les fichiers dans le répertoire temporaire du serveur\n          file.rename(input$inputFiles[i, 4], paste0(dir, \"/\", input$inputFiles[i, 1]))\n        \n        shpFilename <- list.files(dir, pattern = \"*.shp\", full.names = TRUE)\n        nomCouche <- strsplit(input$inputFiles[1, 1], \"\\\\.\")[[1]][1]\n        \n        shape <- readOGR(shpFilename, nomCouche)\n        shape <- sp::spTransform(shape, CRSobj = CRS(paste0(\"+init=epsg:\", epsgPivot)))\n        \n        shape\n     }\n    )\n    \n    ####### recherche du système de projection cible pour le fond de carte fourni ####### \n    epsgCible <- eventReactive(input$inputFiles, \n     {\n       trace(traceLevel, \"recherche du système de projection cible pour le fond de carte fourni\", \"DEBUG\")\n       distances <- lapply(vCentroideZones, rgeos::gDistance, territoire())\n       index <- which.min(distances)\n       epsg <- vZonesEPSG[[index]]\n       epsg\n     }\n   )                                  \n    \n    ############ affichage du bouton Lisser ############\n    observeEvent(input$inputDatas,\n    {\n      if (is.null(input$inputDatas) | input$inputDatas == \"\") \n        return(NULL)\n      \n      trace(traceLevel, \"############ affichage du bouton Lisser ############\", \"DEBUG\")\n      output$btnDynLisser <- renderUI({\n        actionButton(inputId = \"btnDynLisser\", label = \"Lisser\", class = \"btn-primary\")\n      })\n    })\n    \n    ####### sélection base de données ######\n    currentTable <- eventReactive(input$inputDatas, \n      {\n        trace(traceLevel, \"############ sélection base de données ############\", \"DEBUG\")\n        if (is.null(input$inputDatas) | input$inputDatas == \"\")\n          return(NULL)\n\n        coucheTerritoire <- sp::spTransform(territoire(), CRSobj = CRS(paste0(\"+init=epsg:\", epsgCible())))\n        bboxshp <- bbox(coucheTerritoire)\n        xMin <- bboxshp[1, 1]\n        xMax <- bboxshp[1, 2]\n        yMin <- bboxshp[2, 1]\n        yMax <- bboxshp[2, 2]\n        \n        sqlite <- DBI::dbDriver(\"SQLite\")\n        cnxBDD <- DBI::dbConnect(sqlite, paste0(cheminBasesDonnees, \"/\", input$inputDatas, \".db\"), flags = SQLITE_RO) \n        vNomTables <- DBI::dbListTables(cnxBDD)\n        \n        if (!exists(\"vNomTables\"))\n        {\n          DBI::dbDisconnect(cnxBDD)\n          message <- paste(\"Pas de table trouvée dans le fichier \", input$inputDatas)\n          session$sendCustomMessage(type = 'msgboxError', message = message)\n          warning(type = 'msgboxError', message = paste(\"Pas de table trouvée dans le fichier \", input$inputDatas))\n          return(NULL)\n        }\n        \n        if (length(vNomTables) != 1)\n        {\n          session$sendCustomMessage(type = 'msgboxError', message = paste(\"La base de données\", vNomTables, \" doit contenir une et une seule table.\"))\n          DBI::dbDisconnect(cnxBDD)\n          return(NULL)\n        }\n        \n        # Filtrer les colonnes en fonction de ce qui est indiqué dans le fichier properties - ne pas oublier x et y\n        nomSource <- strsplit(as.character(input$inputDatas[1]), \"/\")[[1]][2]\n        millesime <- strsplit(as.character(input$inputDatas[1]), \"/\")[[1]][3]\n        cle <- paste0(nomSource, \".\", millesime, \".colonnesLissageClassique\")\n        listeColonnes <- fctReadProperty(paste0(getwd(), \"/properties/\", nomFichierConfSource), fields = c(cle))\n        sRequete <- paste(\"select\", listeColonnes, \"from\", vNomTables[1])\n        sRequete <- paste(sRequete,  \"where x >=\", xMin, \"and x <=\", xMax, \"and y >=\", yMin, \"and y<=\", yMax)\n        trace(traceLevel, paste(\"Requête :\", sRequete))\n        progress$set(value = 0.5, detail = 'Sélection des données correspondant au fond de carte')\n\n        tryCatch({\n          debutRequete <- Sys.time()\n          dfBase <- DBI::dbGetQuery(cnxBDD, sRequete)\n          trace(traceLevel, paste0(\"Durée requête : \", round(Sys.time() - debutRequete), \"s\\n\"))\n        }, warning = function(w) {\n        }, error = function(e) {\n          message <- paste(\"Erreur lors de la lecture de la table. Requete:\", sRequete, e, sep = \"\\n\")\n          trace(traceLevel, message, \"ERROR\")\n          stop(message)\n        }, finally = {\n          DBI::dbDisconnect(cnxBDD)\n        })\n\n        # suppression des colonnes ayant au moins un NA\n        dfBase <- dfBase[ , colSums(is.na(dfBase)) == 0]\n        \n        # suppression des colonnes non numériques\n        dfBase <- dfBase[ , sapply(dfBase, class) == \"numeric\" | sapply(dfBase, class) == \"integer\" ]\n        \n        if (nrow(dfBase) == 0)\n        { \n          message <- paste(\"Aucune donnée ne correspond à l'intersection données / fond de carte\")\n          session$sendCustomMessage(type = 'msgboxError', message = message)\n          trace(message, \"WARN\")\n          \n          # TODO: supprimer le bouton lisser\n          return(NULL)\n        }\n        \n        dfBase\n      }\n    )\n    \n    ####### lissage des données #######\n    dfLisse <- eventReactive(input$btnDynLisser, {\n      trace(traceLevel, \"############ lissage des données ############\", \"DEBUG\")\n      if (is.null(input$btnDynLisser))\n       return(NULL)\n     \n     if (input$btnDynLisser == 0)\n       return(NULL)\n\n        debutLissage <- Sys.time()\n        dfLisse <- btb::kernelSmoothing( dfObservations = currentTable()\n                                      , cellSize = input$pas\n                                      , bandwidth = input$sliderRayon\n                                      , fUpdateProgress = updateProgress)\n        trace(traceLevel, paste0(\"Durée lissage : \", round(Sys.time() - debutLissage), \"s\"))\n        \n        nbObsAvantElagage <- nrow(dfLisse)\n        dfLisse <- dfLisse[dfLisse$nbObsLisse >= NB_OBS_MIN, ]\n        trace(traceLevel, paste(\"Elagage pour secret - nb carreaux supprimés:\", nbObsAvantElagage - nrow(dfLisse), \"- avant :\", nbObsAvantElagage, \"- après:\", nrow(dfLisse), \"- seuil:\", NB_OBS_MIN, \"obs - nb obs min:\", min(dfLisse$nbObsLisse), \"- nb obs max:\", max(dfLisse$nbObsLisse)))\n        \n       # traitement post-lissage\n        nomSource <- strsplit(as.character(input$inputDatas[1]), \"/\")[[1]][2]\n        millesime <- strsplit(as.character(input$inputDatas[1]), \"/\")[[1]][3]\n        cle <- paste0(nomSource, \".\", millesime, \".traitementPostLissage\")\n        instructions <- fctReadProperty(paste0(getwd(), \"/properties/\", nomFichierConfSource), fields = c(cle))\n        instructions <- gsub(pattern = \"\\t\", replacement = \"\", x = instructions)\n\n       tryCatch({\n         debutPostLissage <- Sys.time()\n         eval(parse(text = instructions))\n         trace(traceLevel, paste0(\"Durée post-lissage : \", round(Sys.time() - debutPostLissage), \"s\"))\n       }, warning = function(w) {\n       }, error = function(e) {\n         message <- paste(\"Erreur lors de l'évaluation du traitement post-lissage. Ce traitement sera ignoré.\\n\", instructions, e, sep = \"\\n\")\n         session$sendCustomMessage(type = 'msgboxError', message = message)\n         trace(traceLevel, message, \"ERROR\")\n       }, finally = {\n       })\n        \n      dfLisse\n    })\n\n    ####### affichage et traitement du bouton download #######\n    observeEvent(input$btnDynLisser,\n     {\n       trace(traceLevel, \"############ affichage et traitement du bouton download ############\", \"DEBUG\")\n       output$btnDownload <- downloadHandler(\n        filename = function() { \n            trace(traceLevel, \"############ filename download ############\", \"DEBUG\")\n            fond <- strsplit(basename(input$inputFiles[1, 1]), \"\\\\.\")[[1]][1]\n            source <- as.character(input$inputDatas[1])\n            source <- gsub(\"/\", \"_\", source)\n            pas <- input$pas\n            rayon <- input$sliderRayon\n            var <- input$selectVar\n            nomArchiveSansExt <- paste(fond, source, pas, rayon, var, sep = '_') \n            nomArchiveAvecExt <- paste0(nomArchiveSansExt, \".zip\") \n            trace(traceLevel, paste(\"Téléchargement de\", nomArchiveAvecExt))\n            nomArchiveAvecExt\n        },\n        content = function(file) {\n          trace(traceLevel, \"############ content download ############\", \"DEBUG\")\n          progress$set(value = 0.2, detail = \"Préparation du téléchargement\")\n          dfLisse <- dfLisse()\n          fond <- strsplit(basename(input$inputFiles[1, 1]), \"\\\\.\")[[1]][1]\n          source <- as.character(input$inputDatas[1])\n          source <- gsub(\"/\", \"_\", source)  # TODO: regarder s'il y a moyen d'améliorer le code\n          pas <- input$pas\n          rayon <- input$sliderRayon\n          nomVariableCourante <- input$selectVar\n          nomArchiveSansExt <- paste(fond, source, pas, rayon, nomVariableCourante, sep = '_') \n\n          if (platformOS == WINDOWS)\n            tmpDir <- Sys.getenv(\"TMP\")\n          else\n            tmpDir <- Sys.getenv(\"R_SESSION_TMPDIR\")\n          \n          repCouche <- paste0(tmpDir, \"/\", nomArchiveSansExt)\n          if (!file.exists(repCouche))\n          {\n            dir.create(file.path(repCouche))\n          }\n          \n          repTravailSauve <- getwd()\n          setwd(repCouche)\n          filePathNameLayer <- paste0(repCouche, \"/\", nomArchiveSansExt, \".shp\")\n          \n          progress$set(value = 0.4, detail = \"Préparation de la grille\")\n          rgdal::writeOGR(grille(), filePathNameLayer, nomVariableCourante, driver = \"ESRI Shapefile\", overwrite_layer = \"TRUE\")\n          \n          progress$set(value = 0.6, detail = \"Préparation des données\")\n          save(dfLisse, file = paste0(repCouche, \"/\", nomArchiveSansExt, \".RData\"))\n          liste_export <- paste0(nomArchiveSansExt, c(\".dbf\", \".shp\", \".shx\", \".prj\", \".RData\"))\n          \n          progress$set(value = 0.8, detail = \"Compression des données\")\n          archiveZip <- zip(zipfile = file, files = liste_export)\n          setwd(repTravailSauve)\n          unlink(c(repCouche), recursive = TRUE)\n          trace(traceLevel, paste(\"Téléchargement - Taille du zip :\", round(file.info(file)[, \"size\"]/1024), \"Ko\"), \"INFO\")\n\n          progress$set(value = 0, detail = pbDetailParDefaut)\n          archiveZip\n          },\n          contentType = \"application/zip\"\n       )\n       output$avertissement <- renderUI({div(\"Veillez à respecter le secret statistique avant diffusion.\", style = \"color:red\")})\n       \n       # la version avec le javascript \"onclick\" fonctionne en local mais pas en recette, vraisemblablement à cause d'une différence sur la version du package shiny (comme pour aspect e la barre de progression)\n       # output$telecharger <- renderUI({downloadButton(outputId = 'btnDownload', label = 'Télécharger', onclick = \"return confirm('Je reconnais avoir lu et accepté les règles indiquées dans l onglet Secret statistique.');\")})\n       output$telecharger <- renderUI({downloadButton(outputId = 'btnDownload', label = 'Télécharger')})\n      }\n    )\n\n    ####### affichage des paramètres de lissage utilisés #######\n    observeEvent(input$carteAffichee, {\n     trace(traceLevel, \"############ retour du serveur via javascript ############\", \"DEBUG\")\n      if ( is.null(input$selectVar) )\n        return(NULL)\n      progress$set(value = 0, detail = pbDetailParDefaut)\n\n     message <- paste(\"<b>Paramètres du lissage affiché</b>\")\n     message <- paste(message, \"<pre>Fond de carte: \\t\\t<b>\", strsplit(basename(input$inputFiles[1, 1]), \"\\\\.\")[[1]][1], \"</b>\")\n     message <- paste(message, \"<br>Source: \\t\\t<b>\", as.character(input$inputDatas[1]), \"</b>\")\n     message <- paste(message, \"<br>Pas: \\t\\t\\t<b>\", input$pas, \"</b>\")\n     message <- paste(message, \"<br>Rayon: \\t\\t\\t<b>\", input$sliderRayon, \"</b>\")\n     message <- paste(message, \"<br>Min obs par carreau: \\t<b>\", NB_OBS_MIN, \"</b>\")\n     message <- paste(message, \"<br>Max carreaux affichés:\\t<b>\", NB_MAX_CARREAUX, \"</b>\")\n     \n     trace(traceLevel, paste(\"Paramètres lissage - carte:\", strsplit(basename(input$inputFiles[1, 1]), \"\\\\.\")[[1]][1], \"- Source:\", as.character(input$inputDatas[1]), \"- pas:\", input$pas, \"- rayon:\", input$sliderRayon))\n     output$parametresUtilises <- renderUI({HTML(message)})\n    })\n    \n    ####### calcul de la grille #######\n    grille <- reactive({\n      trace(traceLevel, \"############ calcul de la grille ############\", \"DEBUG\")\n      dfLisse <- dfLisse()\n\n      # création de la grille\n      grille <- btb::smoothingToGrid(grid = dfLisse, epsg = epsgCible(), fUpdateProgress = updateProgress)   # L93\n      \n      # Ne conserver que les carreaux réellement dans le territoire étudié\n      nbCarreauxAvantElagageSecret <- nrow(grille)\n      coucheTerritoire <- sp::spTransform(territoire(), CRSobj = CRS(paste0(\"+init=epsg:\", epsgCible())))\n      grille <- grille[coucheTerritoire, ]\n      \n      trace(traceLevel, paste0(\"Nb carreaux entre territoire et rectangle englobant: \", nbCarreauxAvantElagageSecret - nrow(grille)), \"INFO\")\n      \n      grille\n    })\n    \n    ####### affichage de la liste de sélection pour la carte #######\n    observeEvent(grille(),{\n      trace(traceLevel, \"############ affichage de la liste de sélection pour la carte ############\", \"DEBUG\")\n      listeColonnes <- setdiff(colnames(dfLisse()), c(\"x\", \"y\", \"nbObsLisse\"))\n      output$selectVar <- renderUI({fluidRow( selectInput(inputId = \"selectVar\", label = NULL, choices = listeColonnes))})\n    })\n\n    ####### affichage de la carte WSG84 #######\n    output$map <- renderLeaflet({\n      # observeEvent(input$selectVar, {\n      trace(traceLevel, \"############ affichage de la carte WSG84 ############\", \"DEBUG\")\n\n      if ( is.null(input$selectVar) )\n        return(NULL)\n      \n      fond <- grille()   # L93\n      \n      # Elagage pour performances d'affichage\n      progress$set(value = 0.05, detail = \"élagage pour performance d'affichage\")\n      if (\"nbObsLisse\" %in% colnames(fond@data))\n      {\n        nbCarreauxAvantElagage <- nrow(fond)\n        if (nbCarreauxAvantElagage > NB_MAX_CARREAUX)\n        {\n          fond <- fond[with(fond@data, order(-nbObsLisse)), ]\n          limiteNbObs <- fond$nbObsLisse[NB_MAX_CARREAUX]\n          fond <- fond[fond$nbObsLisse >= limiteNbObs, ]\n          trace(traceLevel, paste(\"Elagage pour performance - nb carreaux supprimés:\", nbCarreauxAvantElagage - nrow(fond), \"- avant :\", nbCarreauxAvantElagage, \"- après:\", nrow(fond), \"- seuil:\", NB_MAX_CARREAUX, \"carreaux - nb Obs min:\", min(fond$nbObsLisse), \"- nb Obs max:\", max(fond$nbObsLisse)))\n        }\n      }\n      else\n      {\n        trace(traceLevel, \"Pas d'élagage de performance car colonne nbObsLisse non trouvée.\", \"WARNING\")\n      }\n\n      progress$set(value = 0.10, detail = \"Préparation de la couche lissée\")\n      fond <- spTransform(fond, CRS = CRS(\"+init=epsg:4326\")) # transformation en WGS84 pour le leaflet\n\n      progress$set(value = 0.20, detail = \"Préparation catégories\")\n      variable <- paste0(\"fond@data$\", input$selectVar)\n      classeIntervalles <- classInt::classIntervals(eval(parse(text = variable)), style = \"kmeans\", n = 5)\n      fond@data$colonneCouleurs <- findColours(classeIntervalles, vNuancesRouge)\n\n      progress$set(value = 0.40, detail = \"Sélection des QP\")\n\n      # Pour ne garder que les QP de la zone étudiée  - permet de ne plus avoir de \"server disconnected\" ou d'éloigner le seuil\n      coucheQPV <- coucheQPVMetropole[fond, ]\n\n      bboxshp <- bbox(fond)\n      xMin <- bboxshp[\"x\", \"min\"]\n      xMax <- bboxshp[\"x\", \"max\"]\n      yMin <- bboxshp[\"y\", \"min\"]\n      yMax <- bboxshp[\"y\", \"max\"]\n      \n      borneInfCategorie <- round(classeIntervalles$brks[1:(length(classeIntervalles$brks) - 1)])\n      borneSupCategorie <- round(classeIntervalles$brks[2:length(classeIntervalles$brks)])\n      labelCategories <- paste(borneInfCategorie, \"-\", borneSupCategorie)\n      \n      # masquer les bornes extrêmes\n      labelCategories[1] <- gsub(paste0(strsplit(labelCategories[1], \" - \")[[1]][1], \" - \"), \"- de \", labelCategories[1])\n      labelCategories[length(classeIntervalles$brks) - 1] <- gsub(paste0(\" - \", strsplit(labelCategories[length(classeIntervalles$brks) - 1], \" - \")[[1]][2]), \"\", labelCategories[length(classeIntervalles$brks) - 1])\n      labelCategories[length(classeIntervalles$brks) - 1] <- paste0(\"+ de \", labelCategories[length(classeIntervalles$brks) - 1])\n\n      heureDebut <- Sys.time()\n      progress$set(value = 0.60, detail = \"Préparation de la carte\")\n      carte <-\n        leaflet() %>% fitBounds(xMin, yMin, xMax, yMax) %>%\n        # addRectangles(lng1 = xMin, lat1 = yMin, lng2 = xMax, lat2 = yMax, fill = FALSE, weight = 3) %>%\n        addPolygons(data = fond, fillColor = ~colonneCouleurs, stroke = FALSE, fillOpacity = 0.7) %>%\n        addPolygons(data = coucheQPV, fillOpacity = 0, color = \"black\", weight = 1, opacity = 1) %>%\n        addPolygons(data = territoire(), weight = 3, color = \"black\", opacity = 1, fillOpacity = 0) %>%\n        addLegend(colors = vNuancesRouge, values = eval(parse(text = variable)), position = \"bottomleft\", title = \"Catégories\", labels = labelCategories, opacity = 0.7)\n      \n      isolate(\n      if (input$afficheOSM == TRUE)\n        carte <- carte %>% addTiles(urlTemplate = urlFondDeCarte) %>% addTiles()\n      )\n      \n      # pour conserver le niveau de zoom et la position de la carte\n      isolate(\n        if (input$conserverZoom == \"TRUE\")\n        {\n          if (!is.null((input$map_zoom)) & !is.null(input$map_bounds))\n          {\n            xMinZoom <- input$map_bounds$west\n            xMaxZoom <- input$map_bounds$east\n            yMinZoom <- input$map_bounds$south\n            yMaxZoom <- input$map_bounds$north\n            xCenter <- (xMaxZoom + xMinZoom) / 2\n            yCenter <- (yMaxZoom + yMinZoom) / 2\n            carte <- carte %>% setView(lng = xCenter, lat = yCenter, zoom = input$map_zoom)\n          }\n        }\n      )\n      \n      trace(traceLevel, paste0(\"Durée préparation carte : \", round(Sys.time() - heureDebut), \"s\"), \"DEBUG\")\n      progress$set(value = 0.80, detail = \"Préparation de l'affichage par votre navigateur\")\n\n      debutGC <- Sys.time()\n      gc()\n      trace(traceLevel, paste(\"durée gc() :\", Sys.time() - debutGC), \"DEBUG\")\n      trace(traceLevel, paste(\"object.size(carte) :\", round(object.size(carte) / 1048576, digits = 3), \"Mo\"), \"DEBUG\")\n      trace(traceLevel, paste(\"memory.size() :\", memory.size(), \"Mo\"), \"DEBUG\")\n      trace(traceLevel, paste(\"memory.limit() :\", memory.limit(), \"Mo\"), \"DEBUG\")\n\n      # output$map <- renderLeaflet({carte})\n      carte\n    })\n \n    ####### affichage de la couche openStreetMap\n    observeEvent(input$afficheOSM, {\n        if (input$afficheOSM == TRUE)\n        {\n          leafletProxy(\"map\")  %>% addTiles(urlTemplate = urlFondDeCarte)  %>%\n            addTiles()\n        }\n        else\n        {\n          leafletProxy(\"map\") %>%\n            clearTiles()\n        }\n      }\n    )\n\n  }\n)",
    "created" : 1499166577401.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1401598121",
    "id" : "2B2438AE",
    "lastKnownWriteTime" : 1499185645,
    "last_content_update" : 1499185645943,
    "path" : "D:/S3QCEA/programmation/R/ALICE/server.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}